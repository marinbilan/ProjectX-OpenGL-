//
// VERTEX SHADER
//
const char* VS7 =
"#version 330 \r\n"
""
"in vec3 position;"
"in vec3 normal;"
"in vec2 textureCoordinates;"
"in vec3 tangent;"
""
"out vec2 pass_textureCoordinates;"
"out vec3 toLightVector;" // MULTIPLE
"out vec3 toCameraVector;"
"out float visibility;"
""
"uniform mat4 transformationMatrix;"
"uniform mat4 projectionMatrix;"
"uniform mat4 viewMatrix;"
""
"uniform vec3 lightPositionEyeSpace;" // MULTIPLE
""
"const float density = 0;"
"const float gradient = 5.001;"
""
// "uniform vec4 plane;"
""
"void main(void) {"
""
"	vec4 worldPosition = transformationMatrix * vec4(position, 1.0);"
// "	gl_ClipDistance[0] = dot(worldPosition, plane);"
"	mat4 modelViewMatrix = viewMatrix * transformationMatrix;"
"	vec4 positionRelativeToCam = modelViewMatrix * vec4(position, 1.0);"
"	gl_Position = projectionMatrix * positionRelativeToCam;"
""
"	pass_textureCoordinates = textureCoordinates;"
""
"	vec3 surfaceNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;"
""
"	vec3 norm = normalize(surfaceNormal);"
"	vec3 tang = normalize((modelViewMatrix * vec4(tangent, 0.0)).xyz);"
"	vec3 bitang = normalize(cross(norm, tang));"
""
"	mat3 toTangentSpace = mat3("
"		tang.x, bitang.x, norm.x,"
"		tang.y, bitang.y, norm.y,"
"		tang.z, bitang.z, norm.z"
"		);"
""
"	toLightVector = toTangentSpace * ( (viewMatrix * vec4(lightPositionEyeSpace, 1.0)).xyz - positionRelativeToCam.xyz);"
"	toCameraVector = toTangentSpace * (-positionRelativeToCam.xyz);"
""
"	float distance = length(positionRelativeToCam.xyz);"
"	visibility = exp(-pow((distance*density), gradient));"
"	visibility = clamp(visibility, 0.0, 1.0);"
""
"}";
//
// FRAGMENT SHADER
//
const char* FS7 =
"#version 330 \r\n"
""
"in vec2 pass_textureCoordinates;"
"in vec3 toLightVector;" // MULTIPLE
"in vec3 toCameraVector;"
"in float visibility;"
""
"out vec4 out_Color;"
""
"uniform sampler2D modelTexture;"
"uniform sampler2D normalMap;"
""
"uniform vec3 lightColour;" // MULTIPLE
							// "uniform vec3 attenuation;" // MULTIPLE
	"uniform float shineDamper;"
	"uniform float reflectivity;"
	// "uniform vec3 skyColour;"
	""
	"void main(void) {"
	""
	"	vec4 normalMapValue = 2.0 * texture(normalMap, pass_textureCoordinates, -1.0) - 1.0;"
	""
	"	vec3 unitNormal = normalize(normalMapValue.rgb);"
	"	vec3 unitVectorToCamera = normalize(toCameraVector);"
	""
	"	vec3 totalDiffuse = vec3(0.0);"
	"	vec3 totalSpecular = vec3(0.0);"
	""
	"		float distance = length(toLightVector);"
	"		vec3 attenuation = vec3(0.001);"
	"		float attFactor = attenuation.x + (attenuation.y * distance) + (attenuation.z * distance * distance);"
	"		vec3 unitLightVector = normalize(toLightVector);"
	"		float nDotl = dot(unitNormal, unitLightVector);"
	"		float brightness = max(nDotl, 0.0);"
	"		vec3 lightDirection = -unitLightVector;"
	"		vec3 reflectedLightDirection = reflect(lightDirection, unitNormal);"
	"		float specularFactor = dot(reflectedLightDirection, unitVectorToCamera);"
	"		specularFactor = max(specularFactor, 0.0);"
	"		float dampedFactor = pow(specularFactor, shineDamper);"
	"		totalDiffuse = totalDiffuse + (brightness * lightColour) / attFactor;"
	"		totalSpecular = totalSpecular + (dampedFactor * reflectivity * lightColour) / attFactor;"
	""
	"	totalDiffuse = max(totalDiffuse, 0.1);"
	""
	"	vec4 textureColour = texture(modelTexture, pass_textureCoordinates, -1.0);"
	"	if (textureColour.a<0.5) {"
	"		discard;"
	"	}"
	""
	"	out_Color = vec4(totalDiffuse, 1.0) * textureColour + vec4(totalSpecular, 1.0);"
	//"	out_Color = mix(vec4(skyColour, 1.0), out_Color, visibility);"
	""
	"}";